#? stdtmpl() | standard
#
#import std/[options, tables, strutils, algorithm]
#
#import ../../../api
#import ../../../helpers
#
#proc generate*(
#    def: ClassDefinition): string =
#  let selfType = def.name
#
#  result = autogenDisclaimer()
#
import ../../ffi

#  if def.inherits.isSome():
#    let parentName = def.inherits.unsafeGet()
#    let parentModule = parentName.toLower().safeImport()
#
#    # We do need ../types/$module here because for some reason, ./"object" is refused.
import ../types/$parentModule

type
  ${def.name}* = object of ${parentName}
#  else:
type
  ${def.name}* = object of RootObj
    opaque*: pointer
#  end if

#  # We need to special-case two types: Object and RefCounted.
#  #
#  # Object-based classes are freed manually (or rather, =destroy'd) and we
#  # forbid copying to prevent double frees.
#  #
#  # RefCounted-based classes carry a reference count, strangely enough, and
#  # we access this in our =destroy hook to see if we (otherwise Godot) must
#  # free the object. The =copy hook just bumps the reference up.
#
#  if def.name == "Object" or def.name == "RefCounted":
import ../../hooks

generateHooks(${def.name}, $def.isRefcounted)

#  elif def.isSingleton():
proc `=destroy`*(st: var $def.name) =
  discard

#  end if
#  for enu in def.enums.get(@[]):
#    if not enu.name.startsWith("Variant."):
#      var duplicates = initOrderedTable[int, seq[EnumValue]]()
#      var lastValue = none int
#
type
#      let enumName = enu.name
  $enumName* {.size: sizeof(cint).} = enum
#      for value in enu.values.sortedByIt(it.value):
#        if lastValue.isSome() and lastValue.unsafeGet() == value.value:
#          if value.value notin duplicates:
#            duplicates[value.value] = @[value]
#          else:
#            duplicates[value.value] &= value
#          end if
#        else:
#          lastValue = some value.value
#
#          let cleanName = value.cleanName(enu)
    $cleanName = $value.value
#        end if
#      end for
#      if len(duplicates) > 0:

#        for value, dupes in pairs(duplicates):
#          for duplicate in dupes:
#            let cleanDupe = duplicate.cleanName(enu)
const $cleanDupe*: $enumName = $enumName($value)
#          end for
#        end for
#      end if

#    end if
#  end for

var instanceBindingCallbacks: GDExtensionInstanceBindingCallbacks