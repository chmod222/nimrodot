# Builtin Class Variant (Procs) [non-autogenerated]
import std/sugar

import ../../nodot
import ../ffi
import ../utils
import ../helpers
import ./types/variant

export variant

import ./types

type
  VariantCallException* = object of CatchableError
    code*: CallErrorType
    argument*: int32
    expected*: Type

proc newVariant*(): Variant =
  gdInterfacePtr.variant_new_nil(addr result)

proc newVariant*(`from`: Variant): Variant =
  gdInterfacePtr.variant_new_copy(addr result, unsafeAddr `from`)

proc newVariant*[T](`from`: T): Variant =
  when T is Variant:
    `from`
  else:
    var fromType {.global.} = gdInterfacePtr.get_variant_from_type_constructor(
      cast[GDExtensionVariantType](T.variantTypeId()))

    fromType(addr result, unsafeAddr `from`)

proc castTo*[T](self: Variant; _: typedesc[T]): T =
  when T is Variant:
    self
  else:
    var toType {.global.} = gdInterfacePtr.get_variant_to_type_constructor(
      cast[GDExtensionVariantType](T.variantTypeId()))

    toType(addr result, unsafeAddr self)

template `%`*(p: typed): Variant = p.newVariant()

proc destroy*(self: sink Variant) =
  gdInterfacePtr.variant_destroy(unsafeAddr self)

proc `$`*(variant: Variant): string =
  var gdString: String = default(String)

  gdInterfacePtr.variant_stringify(unsafeAddr variant, addr gdString)

  return $gdString

# I apologize.
proc raiseMeMaybe(callError: GDExtensionCallError) =
  if callError.error != GDEXTENSION_CALL_OK:
    var exc = newException(VariantCallException, "error during variant call")

    exc.code = CallErrorType(ord(callError.error))
    exc.argument = callError.argument
    exc.expected = cast[Type](callError.expected)

    raise exc

proc raiseIf[T](cond: GDExtensionBool; errorCond: bool; exc: typedesc[T]; message: string) =
  let got = cond == 1

  if got == errorCond:
    raise newException(T, message)

proc call*(self: var Variant; meth: string; args: varargs[Variant, newVariant]): Variant =
  var callError: GDExtensionCallError

  var ffiArgs = collect(newSeqOfCap(len(args))):
    for i in 0..high(args):
      cast[GDExtensionConstVariantPtr](unsafeAddr args[i])

  var methodName = toGodotStringName(meth)

  gdInterfacePtr.variant_call(
    cast[GDExtensionVariantPtr](addr self),
    cast[GDExtensionConstStringNamePtr](addr methodName),
    cast[ptr GDExtensionConstVariantPtr](if len(ffiArgs) > 0: addr ffiArgs[0] else: nil),
    len(ffiArgs),
    cast[GDExtensionVariantPtr](addr result),
    addr callError)

  callError.raiseMeMaybe()

proc call*(ty: Type; meth: string; args: varargs[Variant, newVariant]): Variant =
  var callError: GDExtensionCallError

  var ffiArgs = collect(newSeqOfCap(len(args))):
    for i in 0..high(args):
      cast[GDExtensionConstVariantPtr](unsafeAddr args[i])

  var methodName = toGodotStringName(meth)

  gdInterfacePtr.variant_call_static(
    cast[GDExtensionVariantType](ty),
    cast[GDExtensionConstStringNamePtr](addr methodName),
    cast[ptr GDExtensionConstVariantPtr](if len(ffiArgs) > 0: addr ffiArgs[0] else: nil),
    len(ffiArgs),
    cast[GDExtensionVariantPtr](addr result),
    addr callError)

  callError.raiseMeMaybe()

proc get*(self: Variant; key: Variant): Variant =
  var isValid: GDExtensionBool

  gdInterfacePtr.variant_get(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionConstVariantPtr](unsafeAddr key),
    cast[GDExtensionVariantPtr](addr result),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc get*(self: Variant; key: string): Variant =
  var isValid: GDExtensionBool

  var keyName = toGodotStringName(key)

  gdInterfacePtr.variant_get_named(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionConstStringNamePtr](addr keyName),
    cast[GDExtensionVariantPtr](addr result),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc set*(self: var Variant; key, value: Variant) =
  var isValid: GDExtensionBool

  gdInterfacePtr.variant_set(
    cast[GDExtensionVariantPtr](addr self),
    cast[GDExtensionConstVariantPtr](unsafeAddr key),
    cast[GDExtensionConstVariantPtr](unsafeAddr value),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc set*(self: var Variant; key: string; value: Variant) =
  var isValid: GDExtensionBool

  var keyName = toGodotStringName(key)

  gdInterfacePtr.variant_set_named(
    cast[GDExtensionVariantPtr](addr self),
    cast[GDExtensionConstStringNamePtr](addr keyName),
    cast[GDExtensionConstVariantPtr](unsafeAddr value),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc `[]`*(self: Variant; idx: int64): Variant =
  var
    isValid: GDExtensionBool = 0
    isOOB: GDExtensionBool = 0

  gdInterfacePtr.variant_get_indexed(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    idx,
    cast[GDExtensionVariantPtr](addr result),
    addr isValid,
    addr isOob)

  isValid.raiseIf(false, ValueError, "invalid operation")
  isOOB.raiseIf(true, ValueError, "index out of bounds")

proc `[]`*(self: Variant; key: Variant): Variant =
  var isValid: GDExtensionBool = 0

  gdInterfacePtr.variant_get_keyed(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionConstVariantPtr](unsafeAddr key),
    cast[GDExtensionVariantPtr](addr result),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc `[]=`*(self: var Variant; idx: int64; value: Variant): Variant =
  var
    isValid: GDExtensionBool = 0
    isOOB: GDExtensionBool = 0

  gdInterfacePtr.variant_set_indexed(
    cast[GDExtensionVariantPtr](addr self),
    idx,
    cast[GDExtensionConstVariantPtr](unsafeAddr value),
    addr isValid,
    addr isOob)

  isValid.raiseIf(false, ValueError, "invalid operation")
  isOOB.raiseIf(true, ValueError, "index out of bounds")

proc `[]=`*(self: var Variant; key, value: Variant): Variant =
  var isValid: GDExtensionBool = 0

  gdInterfacePtr.variant_set_keyed(
    cast[GDExtensionVariantPtr](addr self),
    cast[GDExtensionConstVariantPtr](unsafeAddr key),
    cast[GDExtensionConstVariantPtr](unsafeAddr value),
    addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

proc hash*(self: Variant): int64 =
  gdInterfacePtr.variant_hash(unsafeAddr self)

proc hash*(self: Variant; recursionCount: int64): int64 =
  gdInterfacePtr.variant_recursive_hash(unsafeAddr self, recursionCount)

proc hashCompare*(a, b: Variant): bool =
  gdInterfacePtr.variant_hash_compare(
    cast[GDExtensionConstVariantPtr](unsafeAddr a),
    cast[GDExtensionConstVariantPtr](unsafeAddr b)) != 0

converter booleanize*(self: Variant): bool =
  gdInterfacePtr.variant_booleanize(cast[GDExtensionConstVariantPtr](unsafeAddr self)) != 0

# Needs testing
iterator items*(self: Variant): Variant =
  let selfPtr = cast[GDExtensionConstVariantPtr](unsafeAddr self)

  var iter, item: Variant;
  var isValid: GDExtensionBool;

  discard gdInterfacePtr.variant_iter_init(
    selfPtr,
    cast[GDExtensionVariantPtr](addr iter),
    addr isValid)

  while isValid == 1:
    gdInterfacePtr.variant_iter_get(selfPtr, addr iter, addr item, addr isValid)

    yield self[item.castTo(int64)]

    if gdInterfacePtr.variant_iter_next(selfPtr, addr iter, addr isValid) == 0:
      break

proc duplicate*(self: Variant; deep: bool = true): Variant =
  gdInterfacePtr.variant_duplicate(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionVariantPtr](addr result),
    cast[GDExtensionBool](deep))

proc getType*(self: Variant): Type =
  Type(int(gdInterfacePtr.variant_get_type(
    cast[GDExtensionConstVariantPtr](unsafeAddr self))))

proc hasMethod*(self: Variant; meth: string): bool =
  var methodName = toGodotStringName(meth)

  gdInterfacePtr.variant_has_method(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionConstStringNamePtr](addr methodName)) != 0

proc hasProperty*(ty: Type; prop: string): bool =
  var propName = toGodotStringName(prop)

  gdInterfacePtr.variant_has_member(
    cast[GDExtensionVariantType](ty),
    cast[GDExtensionConstStringNamePtr](addr propName)) != 0

proc contains*(self: Variant; key: Variant): bool =
  var isValid: GDExtensionBool

  result = gdInterfacePtr.variant_has_key(
    cast[GDExtensionConstVariantPtr](unsafeAddr self),
    cast[GDExtensionConstVariantPtr](unsafeAddr key),
    addr isValid) != 0

  isValid.raiseIf(false, ValueError, "invalid operation")

proc typeName*(ty: Type): String =
  gdInterfacePtr.variant_get_type_name(
    cast[GDExtensionVariantType](ty),
    cast[GDExtensionStringPtr](addr result))

proc canConvertertTo*(a, b: Type; strict: bool = false): bool =
  if strict:
    gdInterfacePtr.variant_can_convert_strict(
      cast[GDExtensionVariantType](a),
      cast[GDExtensionVariantType](b)) != 0
  else:
    gdInterfacePtr.variant_can_convert(
      cast[GDExtensionVariantType](a),
      cast[GDExtensionVariantType](b)) != 0

template invokeInner(operator: GDExtensionVariantOperator; a, b: untyped) =
  var isValid: GDExtensionBool;

  gdInterfacePtr.variant_evaluate(operator,
      cast[GDExtensionConstVariantPtr](a),
      cast[GDExtensionConstVariantPtr](b),
      cast[GDExtensionVariantPtr](addr result),
      addr isValid)

  isValid.raiseIf(false, ValueError, "invalid operation")

template invoke(operator: GDExtensionVariantOperator; a, b: Variant) =
  operator.invokeInner(unsafeAddr a, unsafeAddr b)

template invoke(operator: GDExtensionVariantOperator; a: Variant) =
  operator.invokeInner(unsafeAddr a, nil)


proc `==`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_EQUAL.invoke(a, b)

proc `!=`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_NOT_EQUAL.invoke(a, b)

proc `<`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_LESS.invoke(a, b)

proc `<=`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_LESS_EQUAL.invoke(a, b)

proc `>`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_GREATER.invoke(a, b)

proc `>=`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_GREATER_EQUAL.invoke(a, b)

proc `+`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_ADD.invoke(a, b)

proc `+`*(a: Variant): Variant =
  GDEXTENSION_VARIANT_OP_POSITIVE.invoke(a)

proc `-`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_SUBTRACT.invoke(a, b)

proc `-`*(a: Variant): Variant =
  GDEXTENSION_VARIANT_OP_NEGATE.invoke(a)

proc `*`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_MULTIPLY.invoke(a, b)

proc `/`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_DIVIDE.invoke(a, b)

proc `%`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_MODULE.invoke(a, b)

proc `**`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_POWER.invoke(a, b)

proc `<<`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_SHIFT_LEFT.invoke(a, b)

proc `>>`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_SHIFT_RIGHT.invoke(a, b)

proc `&`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_BIT_AND.invoke(a, b)

proc `|`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_BIT_OR.invoke(a, b)

proc `^`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_BIT_XOR.invoke(a, b)

proc `~`*(a: Variant): Variant =
  GDEXTENSION_VARIANT_OP_BIT_NEGATE.invoke(a)

proc `and`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_AND.invoke(a, b)

proc `or`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_OR.invoke(a, b)

proc `xor`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_XOR.invoke(a, b)

proc `not`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_NOT.invoke(a, b)

proc `in`*(a, b: Variant): Variant =
  GDEXTENSION_VARIANT_OP_IN.invoke(a, b)